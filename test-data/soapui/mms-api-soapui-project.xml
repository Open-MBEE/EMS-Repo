<?xml version="1.0" encoding="UTF-8"?>
<con:soapui-project activeEnvironment="Default" name="mms-api" resourceRoot="${projectDir}" soapui-version="5.0.0" xmlns:con="http://eviware.com/soapui/config"><con:settings/><con:interface xsi:type="con:RestService" wadlVersion="http://wadl.dev.java.net/2009/02" name="mms" type="rest" basePath="/alfresco/service" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache/><con:endpoints><con:endpoint>https://{server}</con:endpoint></con:endpoints><con:resource name="/workspaces" path="/workspaces{server}"><con:description>All resources are "namespaced" by the workspace (aka branch).</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{workspaceId}" path="/{workspaceId}"><con:description>Read operations for workspaces</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Workspace ID under consideration. "master" is always defined and is the "trunk" workspace to whih all other workspaces should be merged. "master" is what is contained at the Alfresco sites level.</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/artifacts" path="/artifacts"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{artifactId}" path="/{artifactId}"><con:description>Create, Read, Update, and Delete operations for artifacts</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>artifactId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for artifacts</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>artifacts append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>artifacts append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to artifacts</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>artifacts not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>artifacts conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to artifacts due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for artifacts</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>artifacts update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>artifacts create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>artifacts create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to artifacts</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>artifacts not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>artifacts conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to artifacts due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for artifacts</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>artifacts delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>artifacts delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to artifacts</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>artifacts not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete artifacts due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for artifacts</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of artifacts, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>artifacts read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to artifacts</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>artifacts not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read artifacts due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource></con:resource><con:resource name="/sites" path="/sites"><con:description>Read operations for sites</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{siteId}" path="/{siteId}"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Alfresco site identifier for the project under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/configurations" path="/configurations"><con:description>Create, Read, Update, and Delete operations for configurations</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{configurationId}" path="/{configurationId}"><con:description>Create, Read, Update, and Delete operations for configurations</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>configurationId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>ID for the configuration under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/snapshots" path="/snapshots"><con:description>Get snapshots for the specified configuration</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>configurationId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>snapshots create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/products" path="/products"><con:description>Get products for the specified configuration</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>configurationId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for products</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for products</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>products create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for products</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for configurations</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for configurations</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>configurations create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for configurations</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for configurations</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for configurations</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>configurations create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for configurations</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/projects" path="/projects"><con:description>Read operations for projects</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{projectId}" path="/{projectId}"><con:description>Read operations for projects</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>projectId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>MD project ID for the project under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="get" method="GET"><con:description>Read operation for projects</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of projects, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>projects read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to projects</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>projects not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read projects due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="get" method="GET"><con:description>Retrieve all projects for which user has read permissions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of projects, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>projects read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to projects</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>projects not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read projects due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/products" path="/products"><con:description>Create, Read, Update, and Delete operations for products</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{productId}" path="/{productId}"><con:description>Create, Read, Update, and Delete operations for products</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>productId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the product (document) under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/views" path="/views"><con:description>Read operations for views</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>productId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="get" method="GET"><con:description>Read operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/snapshots" path="/snapshots"><con:description>Scoped under /configurations and /products</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>productId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{snapshotId}" path="/{snapshotId}"><con:description>Create, Read, Update, and Delete operations for snapshots</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>productId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>snapshotId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>ID for the snapshot under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>snapshots create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>snapshots create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for snapshots</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for products</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for products</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>products create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for products</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for products</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for products</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>products create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for products</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Retrieve all products for which user has read permissions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource></con:resource><con:method name="get" method="GET"><con:description>Retrieve all sites for which user has read permissions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of sites, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>sites read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to sites</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>sites not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read sites due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/views" path="/views"><con:description>Create, Read, Update, and Delete operations for views</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{viewId}" path="/{viewId}"><con:description>Create, Read, Update, and Delete operations for views</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the view under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/elements" path="/elements"><con:description>Create, Read, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{elementId}" path="/{elementId}"><con:description>Create, Read, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the element under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/versions" path="/versions"><con:description>Create, Read, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{versionId}" path="/{versionId}"><con:description>Create, Read, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>versionId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the version under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/comments" path="/comments"><con:description>Create, Read, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{commentId}" path="/{commentId}"><con:description>Create, Read, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>commentId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for comment under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Aspect for resources that are or can be constrained</con:description><con:settings/><con:parameters><con:parameter><con:name>fix</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, fixes the constraint as scoped by the element (defaults false)</con:description></con:parameter><con:parameter><con:name>validate</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, validates the constraint as scoped by the element (defaults false). If specified with fix, overrides fix</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Aspect for resources that are or can be constrained</con:description><con:settings/><con:parameters><con:parameter><con:name>fix</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, fixes the constraint as scoped by the element (defaults false)</con:description></con:parameter><con:parameter><con:name>validate</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, validates the constraint as scoped by the element (defaults false). If specified with fix, overrides fix</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for elements</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for elements</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for views</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for views</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>views create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for views</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for views</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for views</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>views create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for views</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/changesets" path="/changesets"><con:description>Track groups of changes together so they can be rolled back together if necessary as well</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{changesetId}" path="/{changesetId}"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>changesetId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Revert Alfresco to the specified change set</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:status>200</con:status><con:params/><con:description>Successfully reverted the changeset</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="get" method="GET"><con:description>Read operation for changesets</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of changesets, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>changesets read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to changesets</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>changesets not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read changesets due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/elements" path="/elements"><con:description>Create, Read, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{elementId}" path="/{elementId}"><con:description>Create, Read, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the element under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/versions" path="/versions"><con:description>Create, Read, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{versionId}" path="/{versionId}"><con:description>Create, Read, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>versionId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the version under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/comments" path="/comments"><con:description>Create, Read, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{commentId}" path="/{commentId}"><con:description>Create, Read, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>commentId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for comment under consideration</con:description></con:parameter><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Aspect for resources that are or can be constrained</con:description><con:settings/><con:parameters><con:parameter><con:name>fix</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, fixes the constraint as scoped by the element (defaults false)</con:description></con:parameter><con:parameter><con:name>validate</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, validates the constraint as scoped by the element (defaults false). If specified with fix, overrides fix</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Aspect for resources that are or can be constrained</con:description><con:settings/><con:parameters><con:parameter><con:name>fix</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, fixes the constraint as scoped by the element (defaults false)</con:description></con:parameter><con:parameter><con:name>validate</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, validates the constraint as scoped by the element (defaults false). If specified with fix, overrides fix</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for elements</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for elements</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="get" method="GET"><con:description>Read operation for workspaces</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of workspaces, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>workspaces read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to workspaces</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>workspaces not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read workspaces due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for workspaces</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>workspaces append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>workspaces append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to workspaces</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>workspaces not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>workspaces conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to workspaces due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for workspaces</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>workspaces update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>workspaces create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>workspaces create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to workspaces</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>workspaces not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>workspaces conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to workspaces due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for workspaces</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>workspaces delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>workspaces delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to workspaces</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>workspaces not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete workspaces due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for workspaces</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of workspaces, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>workspaces read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to workspaces</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>workspaces not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read workspaces due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/operations" path="/operations{server}"><con:description>Service for executing operations, e.g., like the OCL Execution capabilities in MDK. Details still TBD.</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters></con:resource><con:resource name="/diff" path="/diff{server}"><con:description>Service for diffing between two model versions between projects</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for diff</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>diff append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>diff append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to diff</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>diff not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>diff conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to diff due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for diff</con:description><con:settings/><con:parameters/><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>diff update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>diff create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>diff create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to diff</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>diff not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>diff conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to diff due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for diff</con:description><con:settings/><con:parameters/><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>diff delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>diff delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to diff</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>diff not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete diff due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Aspect for resources that can be diffed or merged</con:description><con:settings/><con:parameters><con:parameter><con:name>sourceTimestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>The source workspace timestamp to use in comparison (if not specified, gets latest)</con:description></con:parameter><con:parameter><con:name>targetTimestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>The target workspace timestamp to use in comparison (if not specified, gets latest)</con:description></con:parameter><con:parameter><con:name>sourceWs</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>The source workspaces to compare against</con:description></con:parameter><con:parameter><con:name>targetWs</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>The target workspaces to compare</con:description></con:parameter><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Recurse depth. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against id, name, documentation, body.</con:description></con:parameter><con:parameter><con:name>type</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Filter results based on specified type</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of diff, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>diff read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to diff</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>diff not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read diff due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/merge" path="/merge{server}"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Aspect for resources that can be diffed or merged</con:description><con:settings/><con:parameters><con:parameter><con:name>sourceWs</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>The source workspaces to compare against</con:description></con:parameter><con:parameter><con:name>targetWs</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>The target workspaces to compare</con:description></con:parameter></con:parameters><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/client" path="/client{server}"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>server</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter><con:name>unregister</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>if specified, indicates deregistration, otherwise if not specified, always registration or update</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://{server}</con:endpoint><con:parameters/></con:request></con:method></con:resource></con:interface><con:restMockService port="8080" path="/" host="LMC-037720" name="mms MockService"><con:settings/><con:properties/><con:restMockAction name="/alfresco/service/workspaces{server}" method="POST" resourcePath="/alfresco/service/workspaces{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}" method="PUT" resourcePath="/alfresco/service/workspaces{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}" method="GET" resourcePath="/alfresco/service/workspaces{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/artifacts/{artifactId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/configurations/{configurationId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/projects" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/projects"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/projects/{projectId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/projects/{projectId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/views" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/changesets" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/changesets"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/changesets/{changesetId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/changesets/{changesetId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}" method="POST" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}" method="PUT" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}" method="DELETE" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}" method="GET" resourcePath="/alfresco/service/workspaces{server}/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/diff{server}" method="POST" resourcePath="/alfresco/service/diff{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/diff{server}" method="PUT" resourcePath="/alfresco/service/diff{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/diff{server}" method="DELETE" resourcePath="/alfresco/service/diff{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/diff{server}" method="GET" resourcePath="/alfresco/service/diff{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/merge{server}" method="POST" resourcePath="/alfresco/service/merge{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath></con:restMockAction><con:restMockAction name="/alfresco/service/client{server}" method="POST" resourcePath="/alfresco/service/client{server}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath></con:restMockAction></con:restMockService><con:properties/><con:wssContainer/><con:databaseConnectionContainer/><con:oAuth2ProfileContainer/></con:soapui-project>
