<?xml version="1.0" encoding="UTF-8"?>
<con:soapui-project activeEnvironment="Default" name="mms-api" resourceRoot="" soapui-version="5.0.0" xmlns:con="http://eviware.com/soapui/config"><con:settings/><con:interface xsi:type="con:RestService" wadlVersion="http://wadl.dev.java.net/2009/02" name="mms" type="rest" basePath="/alfresco/service" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache/><con:endpoints><con:endpoint>https://europaems</con:endpoint></con:endpoints><con:resource name="/workspaces" path="/workspaces"><con:description>This is a parallel of the sites branch and used for namespacing purposes, all the methods respond</con:description><con:settings/><con:parameters/><con:resource name="/{workspaceId}" path="/{workspaceId}"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/artifacts" path="/artifacts"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters></con:resource><con:resource name="/sites" path="/sites"><con:description>Read operations for sites</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{siteId}" path="/{siteId}"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Alfresco site identifier for the project under consideration</con:description></con:parameter></con:parameters><con:resource name="/projects" path="/projects"><con:description>Read operations for projects</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{projectId}" path="/{projectId}"><con:description>Read operations for projects</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>projectId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>MD project ID for the project under consideration</con:description></con:parameter></con:parameters><con:method name="get" method="GET"><con:description>Read operation for projects</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of projects, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>projects read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to projects</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>projects not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read projects due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="get" method="GET"><con:description>Retrieve all projects for which user has read permissions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of projects, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>projects read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to projects</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>projects not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read projects due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/products" path="/products"><con:description>Create, Update, and Delete operations for products</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{productId}" path="/{productId}"><con:description>Create, Update, and Delete operations for products</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>productId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the product (document) under consideration</con:description></con:parameter></con:parameters><con:resource name="/snapshots" path="/snapshots"><con:description>Scoped under /configurations and /products</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>productId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{snapshotId}" path="/{snapshotId}"><con:description>Create, Update, and Delete operations for snapshots</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>siteId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>productId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>snapshotId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>ID for the snapshot under consideration</con:description></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>snapshots create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>snapshots create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>products create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>products create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>products conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for products</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>products delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Retrieve all products for which user has read permissions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of products, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>products read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to products</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>products not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read products due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource></con:resource><con:method name="get" method="GET"><con:description>Retrieve all sites for which user has read permissions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of sites, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>sites read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to sites</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>sites not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read sites due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/views" path="/views"><con:description>Create, Update, and Delete operations for views</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{viewId}" path="/{viewId}"><con:description>Create, Update, and Delete operations for views</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the view under consideration</con:description></con:parameter></con:parameters><con:resource name="/elements" path="/elements"><con:description>Create, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{elementId}" path="/{elementId}"><con:description>Create, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the element under consideration</con:description></con:parameter></con:parameters><con:resource name="/versions" path="/versions"><con:description>Create, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{versionId}" path="/{versionId}"><con:description>Create, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>versionId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the version under consideration</con:description></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/comments" path="/comments"><con:description>Create, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{commentId}" path="/{commentId}"><con:description>Create, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>viewId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>commentId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for comment under consideration</con:description></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>views create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>views create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>views conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>views delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for views</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of views, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>views read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to views</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>views not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read views due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/configurations" path="/configurations"><con:description>Create, Update, and Delete operations for configurations</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{configurationId}" path="/{configurationId}"><con:description>Create, Update, and Delete operations for configurations</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>configurationId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>ID for the configuration under consideration</con:description></con:parameter></con:parameters><con:resource name="/snapshots" path="/snapshots"><con:description>Scoped under /configurations and /products</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>configurationId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{snapshotId}" path="/{snapshotId}"><con:description>Create, Update, and Delete operations for snapshots</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>configurationId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>snapshotId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>ID for the snapshot under consideration</con:description></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>snapshots create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>snapshots create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>snapshots conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>snapshots delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for snapshots</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of snapshots, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>snapshots read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to snapshots</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>snapshots not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read snapshots due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>configurations create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>configurations create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>configurations conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>configurations delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for configurations</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of configurations, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>configurations read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to configurations</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>configurations not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read configurations due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/changesets" path="/changesets"><con:description>Create, Update, and Delete operations for changesets</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for changesets</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of changesets, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>changesets append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>changesets append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to changesets</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>changesets not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>changesets conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to changesets due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for changesets</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of changesets, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>changesets update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>changesets create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>changesets create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to changesets</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>changesets not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>changesets conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to changesets due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for changesets</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of changesets, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>changesets delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>changesets delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to changesets</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>changesets not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete changesets due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for changesets</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of changesets, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>changesets read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to changesets</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>changesets not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read changesets due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/constraints" path="/constraints"><con:description xsi:nil="true"/><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters></con:resource><con:resource name="/elements" path="/elements"><con:description>Create, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{elementId}" path="/{elementId}"><con:description>Create, Update, and Delete operations for elements</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the element under consideration</con:description></con:parameter></con:parameters><con:resource name="/versions" path="/versions"><con:description>Create, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{versionId}" path="/{versionId}"><con:description>Create, Update, and Delete operations for versions</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>versionId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for the version under consideration</con:description></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>versions create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>versions conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>versions delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for versions</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of versions, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>versions read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to versions</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>versions not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read versions due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:resource name="/comments" path="/comments"><con:description>Create, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter></con:parameters><con:resource name="/{commentId}" path="/{commentId}"><con:description>Create, Update, and Delete operations for comments</con:description><con:settings/><con:parameters><con:parameter required="true"><con:name>workspaceId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>elementId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description xsi:nil="true"/></con:parameter><con:parameter required="true"><con:name>commentId</con:name><con:style>TEMPLATE</con:style><con:default xsi:nil="true"/><con:description>Sysml ID for comment under consideration</con:description></con:parameter></con:parameters><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>comments create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>comments conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>comments delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for comments</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of comments, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>comments read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to comments</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>comments not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read comments due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource><con:method name="post" method="POST"><con:description>Append operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter><con:parameter><con:name>background</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>Runs create/update in the asynchronously in the background if true, or synchronously if false or not specified</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements append successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements append started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have write permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user saved resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="put" method="PUT"><con:description>Create/update operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter><con:parameter><con:name>background</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>Runs create/update in the asynchronously in the background if true, or synchronously if false or not specified</con:description></con:parameter></con:parameters><con:representation type="REQUEST"><con:mediaType>application/json</con:mediaType><con:params/></con:representation><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements update successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>201</con:status><con:params/><con:description>elements create successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements create/update started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have create/update permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>409</con:status><con:params/><con:description>elements conflict detected (e.g., intervening update occurred between when user accessed resource and when user updated resource)</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not append to elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="delete" method="DELETE"><con:description>Delete operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter><con:parameter><con:name>background</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>Runs create/update in the asynchronously in the background if true, or synchronously if false or not specified</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements delete successful</con:description></con:representation><con:representation type="RESPONSE"><con:status>202</con:status><con:params/><con:description>elements delete started, but not yet completed</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have delete permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not delete elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method><con:method name="get" method="GET"><con:description>Read operation for elements</con:description><con:settings/><con:parameters><con:parameter><con:name>recurse</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:boolean</con:type><con:default xsi:nil="true"/><con:description>If true, finds all elements recursively based on containment hierarchy</con:description></con:parameter><con:parameter><con:name>recurseDepth</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:integer</con:type><con:default xsi:nil="true"/><con:description>Depth to recurse to. 0 specifies infinite recursion (e.g., until all leaf nodes are found).</con:description></con:parameter><con:parameter><con:name>search</con:name><con:style>QUERY</con:style><con:default xsi:nil="true"/><con:description>Regular expression of the search to be executed at the specified scope. Currently search is against sysml:id, sysml:name, sysml:documentation, sysml:body.</con:description></con:parameter><con:parameter><con:name>timestamp</con:name><con:style>QUERY</con:style><con:type xmlns:xs="http://www.w3.org/2001/XMLSchema">xs:date</con:type><con:default xsi:nil="true"/><con:description>Timestamp to find most recent version of elements, specified in ISO8601 time format.</con:description></con:parameter></con:parameters><con:representation type="RESPONSE"><con:mediaType>application/json</con:mediaType><con:status>200</con:status><con:params/><con:description>elements read successful</con:description></con:representation><con:representation type="FAULT"><con:status>400</con:status><con:params/><con:description>Malformed request by client</con:description></con:representation><con:representation type="FAULT"><con:status>401</con:status><con:params/><con:description>User does not have read permissions to elements</con:description></con:representation><con:representation type="FAULT"><con:status>404</con:status><con:params/><con:description>elements not found</con:description></con:representation><con:representation type="FAULT"><con:status>500</con:status><con:params/><con:description>Could not read elements due to internal server error</con:description></con:representation><con:request name="Request 1" mediaType="application/json"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;entry key="Accept" value="application/json" xmlns="http://eviware.com/soapui/config"/></con:setting></con:settings><con:endpoint>https://europaems</con:endpoint><con:parameters/></con:request></con:method></con:resource></con:resource></con:resource></con:interface><con:restMockService port="8080" path="/" host="LMC-037720" name="mms MockService"><con:settings/><con:properties/><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/><con:responseContent>{ "sites": 
  [
    {
      "name": "europa",
      "title": "Europa",
      "categories": [ "v1", "v2", "v3"]
    } ,
    {
      "name": "ems-support",
      "title": "EMS Support Site",
      "categories": []
    }
  ]
}
</con:responseContent></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/projects" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/projects"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/><con:responseContent># taken from project.post.desc.xml (not currently implemented)
{ 
  "projects": 
  [
    {
      "id": "PROJECT-123456",
      "name": "Europa",
      "projectVersion": "v1"
    },
    {
      "id": "PROJECT-2468",
      "name": "Europa FS",
      "projectVersion": "v35"
    }
  ]
}
</con:responseContent></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/projects/{projectId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/projects/{projectId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/><con:responseContent># taken from configuration.get.desc.xml
{
  "products": [
    {
      "id": "_17_0_2_3_8af0285_1397502950809_504517_66083",
      "name": "Flight System",
      "snapshots": [
          {
          "created": "2014-04-21T17:00:16.645-07:00",
          "creator": "gdubos",
          "id": "_17_0_2_3_8af0285_1397502950809_504517_66083_1398124815059",
          "tag": "",
          "url": "/alfresco/service/snapshots/_17_0_2_3_8af0285_1397502950809_504517_66083_1398124815059"
        }
      ]
    }
  ]
}
</con:responseContent></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/sites/{siteId}/products/{productId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/views/{viewId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/configurations/{configurationId}/snapshots/{snapshotId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/changesets" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/changesets"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/changesets" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/changesets"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/changesets" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/changesets"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/changesets" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/changesets"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/versions/{versionId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}" method="POST" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}" method="PUT" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}" method="DELETE" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction><con:restMockAction name="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}" method="GET" resourcePath="/alfresco/service/workspaces/{workspaceId}/elements/{elementId}/comments/{commentId}"><con:settings/><con:dispatchStyle>SEQUENCE</con:dispatchStyle><con:dispatchPath>/*
// Examples showing how to match based on path, query param and header
// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeadeList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncodig Header List: " + acceptEncodingHeadeList

if( acceptEncodingHeadeList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}

*/
</con:dispatchPath><con:response name="Response 200" httpResponseStatus="200" mediaType="application/json"><con:settings/></con:response></con:restMockAction></con:restMockService><con:properties/><con:wssContainer/><con:oAuth2ProfileContainer/><con:sensitiveInformation/></con:soapui-project>